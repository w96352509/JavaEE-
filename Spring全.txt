目錄 : 基礎介紹 
 
何謂框架
  - 框 : 範圍(解決一部分範圍內的問題)
  - 架 : 支撐(實現開發流程)
  - 框架 : 技術解決與整合方案的半成品

Spring 由來
  - J2EE -> Spring
  - 2002 -> Spring    + Hibernate (ORM框架)
         -> Struts    + Spring + Hibernate (組合已死) 
  - 後續 -> SpringMVC + spring + Hibernate or MyBaits or Spring JPA
  - 2021 -> SpringBoot(把原要設定改成預設值)  
  
Spring 創作目的
  
  - 非侵入式程式設計架構
      - POJO(Plain old Java Object)     // 普通的 Java 物件解不受任何限制
      - 業務邏輯程式 , 不含框架程式碼 	// 資源配置都在 applicationContent.xml
      - 讓業務邏輯可以自由移出各框架
	  - 讓設定檔定義 class 意義
  
  - 管理物件生命週期
      - 透過 xml 的配置並建立物件依賴關係

一站 Web 應用框架
  - 表現層    (Web層)
      - SpringMVC
  - 業務邏輯層(Service層)
      - Spring
  - 資料訪問層
      - SpringORM(DAO層) : JPA / HibernateTrmplate / MyBaits

特性:
  - 輕量級 Framwork
      - 重量級 and 輕量級 : 是否相依容器
        Servlet    Spring
      
	  - 不相依特定 JavaEE
      - 單純地將元件部屬到 spring 中  	  

模組:
  - AOP 攔截器 / ORM / DAO / Web / Context / MVC
  -              Spring Core

技術名詞(重要):
  - Java靜態 new / 動態 Class.forname()
  - IOC 反轉注入 配置於 spring 檔中的物件 擁有第三方來保證創建物建 , 容易管理生命週期
  - DI  依賴注入 建構子 / setter
  - AOP	方面導向 比　webFilter 更強

------------------------------------------------------------------------------------------------------------------------
0620
目錄 : IOC / DI / Bean 配置 /Bean scope / Bean 呼叫 / ref / autowire  
  
基本 Spring 操作(範例 : session01 -> hello) 
  - 1. Bean物件規劃 -> applicationContent.xml 配置 or Java 註釋配置 -> 測試(Junit) 

Spring IOC / DI
  1. 輕量級 Framwork
    - DI  (Dependency Injection)        : 依賴注入     -> 建構子與 get/set 注入
    - IOC (Inversion of Control)        : 反轉控制     -> 透過第三方注入
    - AOP (Aspect Oriented Programming) : 方面導向設計 -> 增強版 webFiliter
  
  2. Bean 的配置(範例 : session02) 
    - 可透過 applicationContent.xml or @Configuration
    - bean scope : 
        1. 單一實例(預設) : singleton
        2. 多個實例       : prototype
        3. Web應用        : request / session / global-session
  
  3. Bean 呼叫( 回傳type : ApplicationContext , 範例 : session02 -> Lotto)
    - xml  配置 : 
	    1. 透過 ClassPathXmlApplicationContext("applicationContext.xml"); // 找到 applicationContext.xml 的 內容
        2. 使用 getBean("Bean id" , Bean物件.class);
    
	- Java 配置 :
        1. 透過	new AnnotationConfigApplicationContext(Java配置檔.class);
        2. 使用 getBean("Bean name" , Bean物件.class);
	
  4. DI 依賴注入(範例 : session02 -> Author)
    - 由 applicationContent.xml 注入參數 (會自動轉型)
	
	方法注入 :
	- <prototype>        : <property name="name(配合 Bean物件的參數名稱)"> <value>John</value> </property>
	- 簡化 p:            : <bean id="" class="" p:參數名稱="">  
       	
	
	建構子注入 :
	- <constructor-arg>  : <constructor-arg index="0" value="Mary"></constructor-arg> // index = 建構子參數順續
	- 簡化 c:            : <bean id="" class="" c:參數名稱="">  

  5. ref 參考配置(範例 : session02 -> Book)
    - 物件名-ref = "bean id" EX: p:name="Java" p:price="150" p:author-ref="author1" 
	
  6. autowire 自動配置(範例 : session02 -> Paper / Color / Size)
    - byType : 超過一個匹配型別就會發生錯誤(Paper 需要 Color and Size 當 <bean> 有超過1個可以匹配時就會發生錯誤)
	    EX: <bean id="paper1" p:id="101" autowire="byType" class="com.spring.core.session02.beans.Paper" />
            // 有兩個可以匹配則錯誤
			<bean id="color1" class="com.spring.core.session02.beans.Color" p:name="紅色" />		
		    <bean id="color2" class="com.spring.core.session02.beans.Color" p:name="白色" />
    
	- byName : 找到對應的 Bean物件 的參數名稱
        EX: Paper.class -> private Color color , private Size size 則對應 Bean id = "color" and "size"	

------------------------------------------------------------------------------------------------------------------------
0624
目錄 : 引入外部資源 / Set , List , Map 資料集合注入 / <bean> 的生命週期 / FactoryBean(少用) 

 1. 引入外部資源(範例: 外部檔: data.properties / Bean : Clazz.java )
      - 外部資源檔型 : properties             // 取名舉例 : clazz.name=Java
	  - 方法 : 
	     1. 不常用 : 
		      <bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
		        <property name="location" value="data.properties" />
	          </bean>
		 2. 常用 <context:properties> 配合 <bean> 的 p:參數="${}" :	
		      <context:property-placeholder location="外部檔名" />
			  <bean id="" p:name="${}" class=""/>
		 
 2.<property>與 util 配置 set / map / list  
	  - 範例 : Teacher , student 
	  - util 先配置在參考配置
		 - Set  配置 :
		     - <property name="Bean物件的參數名稱"> : <set><ref bean=""></ref></set>
		     - <util:set id  ="Bean物件的參數名稱"> :      <ref bean="">
		   
		 - List 配置 :
         	 - <property name="Bean物件的參數名稱"> : <list><value></value></list>	   
        	 - <util:list id ="Bean物件的參數名稱"> :       <value></value>
		   
         - Map 配置  :
             - <property name="Bean物件的參數名稱"> : <map><entry key=""><value></value></entry></map>	
             - <util:map id  ="Bean物件的參數名稱"> : <entry><key><value></value></key><value></value></entry>
 
 3. Bean 的生命週期(範例 : BeanCycle)
      - 開始 : init-method    = "bean物件的方法名稱"
      - 結束 : destroy-method = "bean物件的方法名稱" 透過 ClassPathXmlApplicationContext 關閉(close)	  
 
 4. 工廠創建(少用) : 透過工廠物件新增給 xml 使用並給主物件使用
      - implements FactoryBean<物件>
	     -  getObject()     // 回傳 new 物件()
		 -  getObjectType() // 回傳物件.class
		 -  isSingleton()   // 有 prototype 以 property 為主
------------------------------------------------------------------------------------------------------------------------		0627
目錄 : MVC 基本運作 / interface 的優點 / Java @配置至 xml 掃描
注意 : xml 要掃描 <context:component-scan base-package="要掃描的位置"></context:component-scan>
 
 1. 利用 Java Annotation(@) 進行 DI
      - MVC 註解
         - @Controller / @Service / @Reposirory
         
		 - 運作 : User <-> Controller(組合Bean) <-> Service(驗證物件邏輯服務等) <-> Reposirory(DB連結) <-> DB 			 
	         - Controller 接 Serivce
			 - Serivce    接 Reposirory
			 - Reposirory 接 DB
		 
		 - Service 與 Reposirory 使用 interface(含兩個以上的實作) 
		    - Serivce 可能有很多的 Controller 使用 
            - Repository 可能有多 Service 使用
            - Controller 幾乎都是一對一則不用 interface
	  
	  - 常用註解(@)
         - @Controller 控制類   : 用於註解此 bean 為 MVC 的控制層
         - @Compontent 元件     : 用於註解此 bean 被 Spring 管理物件生命週期
         - @Service             : 用於註解此 bean 為 MVC 的業務層
         - @Reposirory          : 用於註解此 bean 為 MVC 的訪問層	
             - @Compontent -> public @interface Service / Reposirory // @Compontent = @Service / @Reposirory
         - @Resource 資源類     : 用於自動照 ByName 配置(J2EE)
         - @Autowirted 自動綁定 : 用於自動照 ByType 配置(Spring) 可配合使用	@Qualifier 限定詞 = @Resource 效果
		     - 也可當作建立實體
		 - @Bean 方法及注入     : @Configuration註解或 @Component註解類中使用 @Bean批註
		 - @Value               : 賦予預設值可搭配 Spring EL 語法使用
		     - 普通用法 : @Value(value="")
			 - 集合用法 :
			     - List : @Value(value = "#{${物件名稱:{'值','值'}}}")
				 - Set  : @Value(value = "#{${物件名稱:{'值','值'}}}")
				 - Map  : @Value(value = "#{${物件名稱: {'K': 'V', 'K': 'V'}}}")
				 - #{}  : 使用 Spring EL
		 
		 - @Scope               : 物件範圍
		 - @PropertySource("classpath:") 外部配置
		     - 配合 @Value(value="${}") // Array[] , Set , 正常型別
             - #{}  使用 Spring EL      // List(將分隔符號去除(split)) , Map
			     - List : @Value(value="#{'${物件名稱}'.split('分隔符號')}")
				 - Map  : @Value(value="#{${物件名稱}}")
			 
------------------------------------------------------------------------------------------------------------------------	 
0701 
目錄 : 代理模式(動/靜)
 
 代理模式 : 不可直接使用原物件需透過代理物件控制訪問
   目的 : 將公開方法與業務邏輯分開          
 
 靜態代理(範例 : session04.sta) :  
   必須 : 代理物件與被代理物件要實作同一介面
   規格 : 代理物件 + 建構式(將代理物件注入) + 覆寫方法
   呼叫 : 被代理物件 = new 代理者(代理物件)
   優點 : 直覺快速
   缺點 : 只能單一

 動態代理(範例 : session04.dyn / cglib)   
   分為 : JDK 代理 / cglib 代理
      
	  - JDK 代理 : 僅支援 interface 
	      - JDK1.3 後可使用 , 不必為特定物件代理 , 可使用一個 Handler(處理者)服務各物件
          必須     : 處理者必須實作 java.lang.reflect.InvocationHandler
	      規格     :  
		    代理物件(宣告Object object) + 建構式(將代理物件注入) + 取得代理物件(類別載入器 + 代理物件介面 + 處理代理實現)
          取得代理物件 :
		    - 類別載入器  (type : ClassLodaer)
		    - 代理物件介面(type : Class[])
		    - 取得代理物件(public Object getProxy())
		      - 處理代理實現(type : InvocationHandler -> (proxy(代理物件), method(調用方法), args(參數)))
			      - 調用業務方法(回傳) : method.invoke(代理物件 , 參數);
		      - 取得代理物件(回傳) = Proxy.newProxyInstance(loader , interface , invocationHandler)	  
		 
		   呼叫 : 代理物件 = new 處理者( new 被代理物件).getProxy();

      - Cglib 代理 : 可以實現非介面類
	      原理 : 透過 Echancer(加強子類別) 來覆寫父類別 (子 extend 父)
	      使用 : 方法攔截器 implements MethodInterceptor (方法攔截器) 
		    覆寫 :  intercept(Object obj, Method method, Object[] args, MethodProxy proxy)
			  - return proxy.invokeSuper(Object , Object[]);
		  
		  呼叫 : 
            1. 呼叫增強器   : new Enhancer();
            2. 設定增強對象 : .setSuperclass(new 代理物件);
            3. 設置方法攔截 : .setCallback(new 方法攔截器);	
            4. 創建物件     : .create(); // 需轉型(代理物件)			

 切面程式 Aspect(範例 session04.dyn.MyLogger)
   - 可配合動態代理(JDK)
   - 可以自我定義要帶入的參數(類別(object.getclass) , 執行方法(method.getName) , 參數(args)) 
       EX : public static void before(Class cls, String methodName, Object[] args)    
	   
----------------------------------------------------------------------------------------------------------------------------	  AOP 方面導向( 7/4 )  